"use strict";

var _ = require("lodash");
var async = require("async");
var ini = require("ini");
var path = require("path");
var fs = require("fs");

var git = require("./git");


module.exports = {
  "list":   list,
  "unset":  unset,
  "set":    set,
  "get":    get
};

module.exports.defaults = {
  "inject-issue":     false,
  "confirm-create":   true,
  "repo":             null,
  "context":          3,
  "case-sensitive":   false,
  "signature":        "(automatically generated by [Github-Todos](https://github.com/naholyr/github-todos))",
  "label-whitespace": true,
  "label.TODO":       "TODO",
  "label.FIXME":      "TODO",
  "github.token":     null,
  "github.host":      "api.github.com",
  "github.secure":    true,
  "github.version":   "3.0.0",
  "branches":         "develop,master",
  "remotes":          "origin",
  "files":            "**"
};

module.exports.globals = [
  "github.token",
  "github.host",
  "github.secure",
  "github.version"
];

module.exports.booleans = [
  "inject-issue",
  "confirm-create",
  "case-sensitive",
  "label-whitespace",
  "github.secure"
];

module.exports.numbers = [
  "context"
];


function filename (scope, cb) {
  if (scope === "global") {
    var home = process.platform.match(/^win/) ? process.env.USERPROFILE : process.env.HOME;
    cb(null, path.join(home, ".github-todos"));
  } else {
    git.dir(path.join("..", ".github-todos"), cb);
  }
}

function read (scope, cb) {
  filename(scope, function (err, file) {
    if (err) {
      return cb(err);
    }

    fs.readFile(file, {encoding: "utf8"}, function (err, content) {
      if (err && err.code === "ENOENT") {
        return cb(null, {});
      } else if (err) {
        return cb(err);
      }

      cb(null, ini.parse(content));
    });
  });
}

function write (scope, conf, cb) {
  filename(scope, function (err, file) {
    if (err) {
      return cb(err);
    }

    fs.writeFile(file, ini.stringify(conf), {encoding: "utf8"}, cb);
  });
}

// Check if an option should have a boolean value
function isBoolean (key) {
  return _.contains(module.exports.booleans, key);
}

// Check if an option should have a numeric value
function isNumber (key) {
  return _.contains(module.exports.numbers, key);
}

function asBoolean (value) {
  if (_.isBoolean(value)) {
    return value;
  }
  var iValue = parseInt(value);
  if (!isNaN(iValue)) {
    return value !== 0;
  }
  try {
    return !!JSON.parse(value);
  } catch (e) {
    return false;
  }
}

function list (scope, cb) {
  if (!cb) {
    cb = scope;
    scope = null;
  }

  if (!scope) {
    async.parallel([_.partial(read, "local"), _.partial(read, "global")], function (err, confs) {
      if (err) {
        return cb(err);
      }

      finish(null, _.merge(confs[0], confs[1]));
    });
  } else {
    read(scope, finish);
  }

  function finish (err, conf) {
    if (err) {
      return cb(err);
    }

    cb(null, _.mapValues(conf, function (v, k) {
      return isBoolean(k) ? asBoolean(v) : (isNumber(k) ? Number(v) : v);
    }));
  }
}

/* eslint no-underscore-dangle:0 */
function _unset (option, scope, cb) {
  read(scope, function (err, conf) {
    if (err) {
      return cb(err);
    }

    if (typeof conf[option] === "undefined") {
      return cb();
    }

    delete conf[option];
    write(scope, conf, cb);
  });
}

function unset (option, scope, cb) {
  if (!cb) {
    cb = scope;
    scope = null;
  }

  if (scope === "local") {
    // Force local
    _unset(option, "local", cb);
  } else if (scope === "global") {
    // Force global
    _unset(option, "global", cb);
  } else if (!_.contains(module.exports.globals, option)) {
    // Local option
    _unset(option, "local", cb);
  } else {
    // Global option: unset globally AND locally
    async.parallel([_.partial(_unset, option, "local"), _.partial(_unset, option, "global")], cb);
  }
}

function get (option, scope, cb) {
  if (!cb) {
    cb = scope;
    scope = null;
  }

  // re-use list() to support scope merging
  list(scope, function (err, conf) {
    if (err) {
      return cb(err);
    }

    cb(null, conf[option] || null);
  });
}

function set (option, value, scope, cb) {
  if (!cb) {
    cb = scope;
    scope = null;
  }

  if (!scope) {
    // Set scope from option
    scope = _.contains(module.exports.globals, option) ? "global" : "local";
  }

  read(scope, function (err, conf) {
    if (err) {
      return cb(err);
    }

    conf[option] = value;

    write(scope, conf, cb);
  });
}
