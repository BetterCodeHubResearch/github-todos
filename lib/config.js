"use strict";

var _ = require("lodash");
var async = require("async");

var git = require("./git");


module.exports = {
  "list":   list,
  "unset":  unset,
  "set":    set,
  "get":    get,
  "prefix": prefix
};

module.exports.defaults = {
  "inject-issue":     false,
  "user":             null,
  "repo":             null,
  "context":          3,
  "case-sensitive":   false,
  "signature":        "(automatically generated by [Github-Todos](https://github.com/naholyr/github-todos))",
  "label-whitespace": true,
  "label.TODO":       "TODO",
  "label.FIXME":      "TODO",
  "github.token":     null,
  "github.host":      "api.github.com",
  "github.secure":    true,
  "github.version":   "3.0.0",
  "branches":         "develop,master",
  "remotes":          "origin"
};

module.exports.globals = [
  "github.token",
  "github.host",
  "github.secure",
  "github.version"
];

module.exports.booleans = [
  "inject-issue",
  "case-sensitive",
  "label-whitespace",
  "github.secure"
];


// Get/Set options section
var PREFIX = "github-todos";
function prefix (value) {
  if (value) {
    PREFIX = value;
  }

  return PREFIX;
}

// Check if an option should have a boolean value
function isBoolean (key) {
  return _.contains(module.exports.booleans, key);
}

function asBoolean (value) {
  if (_.isBoolean(value)) {
    return value;
  }
  var iValue = parseInt(value);
  if (!isNaN(iValue)) {
    return value !== 0;
  }
  try {
    return !!JSON.parse(value);
  } catch (e) {
    return false;
  }
}

function cmd (scope, args) {
  var arg = "";
  if (scope === "local") {
    arg = " --local";
  } else if (scope === "global") {
    arg = " --global";
  }

  return "config" + arg + (args ? (" " + args) : "");
}

function list (scope, cb) {
  if (!cb) {
    cb = scope;
    scope = null;
  }

  git.run(cmd(scope, "--get-regexp " + PREFIX + ".*"), function (err, stdout) {
    if (err) {
      return cb(err);
    }

    var result = {};
    stdout.trim().split("\n").forEach(function (line) {
      var key = line.substring(PREFIX.length + 1, line.indexOf(" "));
      var value = line.substring(PREFIX.length + 1 + key.length + 1).trim();
      result[key] = isBoolean(key) ? asBoolean(value) : value;
    });

    cb(null, result);
  });
}

/* eslint no-underscore-dangle:0 */
function _unset (option, arg) {
  return function (cb) {
    git.run("config --unset " + arg + " " + PREFIX + "." + option, function (err) {
      if (err && err.code === 5) {
        // already unset: ignore
        err = null;
      }
      cb(err);
    });
  };
}

function unset (option, scope, cb) {
  if (!cb) {
    cb = scope;
    scope = null;
  }

  if (scope === "local") {
    // Force local
    _unset(option, "--local")(cb);
  } else if (scope === "global") {
    // Force global
    _unset(option, "--global")(cb);
  } else if (!_.contains(module.exports.globals, option)) {
    // Local option
    _unset(option, "--local")(cb);
  } else {
    // Global option: unset globally AND locally
    async.parallel([_unset(option, "--local"), _unset(option, "--global")], cb);
  }
}

function get (option, scope, cb) {
  if (!cb) {
    cb = scope;
    scope = null;
  }

  // `git config option` returns 1 if option is not set
  // it also returns 1 if we're out of a git repository :(
  // re-use exports.list to distinguish cases
  list(scope, function (err, list) {
    if (err) {
      return cb(err);
    }

    cb(null, list[option] || null);
  });
}

function set (option, value, scope, cb) {
  if (!cb) {
    cb = scope;
    scope = null;
  }

  if (!scope) {
    // Set scope from option
    scope = _.contains(module.exports.globals, option) ? "global" : "local";
  }

  git.run(cmd(scope, PREFIX + "." + option + " " + value), function (err /*, stdout */) {
    cb(err || null);
  });
}
