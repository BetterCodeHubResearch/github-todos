"use strict";

var _ = require("lodash");
var ini = require("ini");
var path = require("path");
var Promise = require("bluebird");

var fs = require("./fs");
var pkg = require("../package.json");
var git = require("./git");

// Circular dependencies
var service;
setImmediate(function () {
  service = require("./issue-service");
});


module.exports = {
  "list":     list,
  "unset":    unset,
  "set":      set,
  "get":      get,
  "defaults": getDefaults,
  "globals":  getGlobals
};

var defaults = {
  "inject-issue":     false,
  "confirm-create":   true,
  "open-url":         false,
  "service":          "github",
  "repo":             null,
  "context":          3,
  "case-sensitive":   false,
  "signature":        "(automatically generated by [Github-Todos](https://github.com/naholyr/github-todos))",
  "label-whitespace": true,
  "label.TODO":       "TODO",
  "label.FIXME":      "TODO",
  "github.host":      "api.github.com",
  "github.secure":    true,
  "github.version":   "3.0.0",
  "branches":         "develop,master",
  "remotes":          "origin",
  "files":            "**"
};

var globals = [
  "confirm-create",
  "open-url",
  "github.host",
  "github.secure",
  "github.version"
];

var booleans = [
  "inject-issue",
  "confirm-create",
  "open-url",
  "case-sensitive",
  "label-whitespace",
  "github.secure"
];

var numbers = [
  "context"
];


function getDefaults () {
  return service.list()
    .then(_.partialRight(_.pluck, "conf"))
    .then(_.filter)
    .then(_.flatten)
    .then(_.object)
    .then(_.partialRight(_.merge, defaults));
}

function getGlobals () {
  return service.list()
    .then(_.partialRight(_.pluck, "conf"))
    .then(_.filter)
    .then(_.flatten)
    .then(_.object)
    .then(_.partial(_.union, globals));
}

function isGlobal (option) {
  return getGlobals().then(_.partialRight(_.contains, option));
}

function filename (scope) {
  if (scope === "global") {
    // Global configuration file
    var home = process.platform.match(/^win/) ? process.env.USERPROFILE : process.env.HOME;
    return Promise.resolve(path.join(home, ".github-todos"));
  } else if (scope === "local" || !scope) {
    // Local configuration file
    return git.dir(path.join("..", ".github-todos"));
  } else {
    // Specific configuration file
    return Promise.resolve(scope);
  }
}

// Check if an option should have a boolean value
function isBoolean (key) {
  return _.contains(booleans, key);
}

// Check if an option should have a numeric value
function isNumber (key) {
  return _.contains(numbers, key);
}

function asBoolean (value) {
  if (_.isBoolean(value)) {
    return value;
  }
  var iValue = parseInt(value);
  if (!isNaN(iValue)) {
    return value !== 0;
  }
  try {
    return !!JSON.parse(value);
  } catch (e) {
    return false;
  }
}

function read (scope) {
  return filename(scope)
    .then(fs.readFile)
    .then(function (content) {
      return ini.parse(content || "");
    })
    .then(_.partial(_.merge, {
      "_version": pkg.version
    }))
    // Here we could place some conversion logic:
    // if (conf._version !== pkg.version)
    .then(function (conf) {
      return _.mapValues(conf, function (v, k) {
        return isBoolean(k) ? asBoolean(v) : (isNumber(k) ? Number(v) : v);
      });
    });
}

function write (scope, conf) {
  return filename(scope).then(function (file) {
    return fs.writeFile(file, ini.stringify(conf)).then(_.constant(conf));
  });
}

function list (scope) {
  return scope
    ? read(scope)
    : Promise.all([read("global"), read("local")]).spread(_.merge);
}

/* eslint no-underscore-dangle:0 */
function _unset (option, scope) {
  return read(scope)
    .then(_.partialRight(_.omit, option))
    .then(_.partial(write, scope));
}

function unset (option, scope) {
  if (scope === "local") {
    // Force local
    return _unset(option, "local");
  } else if (scope === "global") {
    // Force global
    return _unset(option, "global");
  } else {
    // Decide depending on option preferences
    return isGlobal(option).then(function (glob) {
      if (!glob) {
        // Local option
        return _unset(option, "local");
      } else {
        // Global option: unset globally AND locally
        return Promise.all([_unset(option, "global"), _unset(option, "local")]).spread(_.merge);
      }
    });
  }
}

function get (option, scope) {
  // re-use list() to support scope merging
  return list(scope).then(_.property(option));
}

function set (option, value, scope) {
  scope = scope
    ? Promise.resolve(scope)
    : isGlobal(option).then(function (glob) { return glob ? "global" : "local"; });

  function update (file) {
    return read(file).then(function (conf) {
      conf[option] = value;
      return write(file, conf);
    });
  }

  return scope.then(filename).then(update);
}
